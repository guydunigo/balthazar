//! This crate contains the base networking protocols to be used by **balthernet**
//! as well as basic structures and functions to handle them.
//!
//! When adding new messages, you can add a from implementation as seen under here.
extern crate bytes;
extern crate futures;
extern crate futures_codec;
extern crate libp2p;
extern crate prost;

pub mod protobuf;
mod task_status;
pub use task_status::TaskStatus;
mod node_type;
pub use node_type::NodeTypeContainer;
pub use prost::{DecodeError, EncodeError, Message};
pub use worker::NodeType;

pub mod smartcontracts {
    //! Data which needs serializing to be stored into the smart-contract.
    include!(concat!(env!("OUT_DIR"), "/smartcontracts.rs"));
}

pub mod manager {
    //! Protocol between managers to achieve self-management of the network.
    include!(concat!(env!("OUT_DIR"), "/manager.rs"));
    pub use proposal::Proposal as ProposalKind;
    pub use propose_failure::Kind as FailureKind;

    use super::worker::TaskErrorKind;

    pub fn try_worker_error_to_definite_error(
        error: TaskErrorKind,
    ) -> Option<TaskDefiniteErrorKind> {
        use TaskDefiniteErrorKind::*;

        match error {
            TaskErrorKind::TimedOut => Some(TimedOut),
            TaskErrorKind::Download => Some(Download),
            TaskErrorKind::Runtime => Some(Runtime),
            TaskErrorKind::Aborted => Some(Aborted),
            _ => None,
        }
    }

    impl From<Proposal> for ManagerMsgWrapper {
        fn from(src: Proposal) -> Self {
            ManagerMsgWrapper {
                msg: Some(manager_msg_wrapper::Msg::Proposal(src)),
            }
        }
    }
}

pub mod worker {
    //! Contains the Protobuf messages classes generated by the **prost** crate.
    use super::protobuf::ProtoBufProtocol;

    /// The version number of the worker protocol
    ///
    /// TODO: Use the crate version ?
    pub const PROTOCOL_VERSION: &str = concat!("/balthazar/worker/", env!("CARGO_PKG_VERSION"));

    pub fn new_worker_protocol() -> ProtoBufProtocol<WorkerMsgWrapper> {
        ProtoBufProtocol::new(PROTOCOL_VERSION.as_bytes())
    }

    include!(concat!(env!("OUT_DIR"), "/worker.rs"));

    pub use task_status::StatusData;
    pub use tasks_execute::TaskExecute;
    pub use worker_msg_wrapper::Msg as WorkerMsg;

    impl From<WorkerMsg> for WorkerMsgWrapper {
        fn from(src: WorkerMsg) -> Self {
            WorkerMsgWrapper { msg: Some(src) }
        }
    }

    impl From<NodeTypeRequest> for WorkerMsgWrapper {
        fn from(src: NodeTypeRequest) -> Self {
            WorkerMsg::NodeTypeRequest(src).into()
        }
    }

    impl From<NodeTypeAnswer> for WorkerMsgWrapper {
        fn from(src: NodeTypeAnswer) -> Self {
            WorkerMsg::NodeTypeAnswer(src).into()
        }
    }

    impl From<Ack> for WorkerMsgWrapper {
        fn from(src: Ack) -> Self {
            WorkerMsg::Ack(src).into()
        }
    }

    impl From<NotMine> for WorkerMsgWrapper {
        fn from(src: NotMine) -> Self {
            WorkerMsg::NotMine(src).into()
        }
    }

    impl From<ManagerRequest> for WorkerMsgWrapper {
        fn from(src: ManagerRequest) -> Self {
            WorkerMsg::ManagerRequest(src).into()
        }
    }

    impl From<ManagerAnswer> for WorkerMsgWrapper {
        fn from(src: ManagerAnswer) -> Self {
            WorkerMsg::ManagerAnswer(src).into()
        }
    }

    impl From<ManagerBye> for WorkerMsgWrapper {
        fn from(src: ManagerBye) -> Self {
            WorkerMsg::ManagerBye(src).into()
        }
    }

    impl From<ManagerPing> for WorkerMsgWrapper {
        fn from(src: ManagerPing) -> Self {
            WorkerMsg::ManagerPing(src).into()
        }
    }

    impl From<ManagerPong> for WorkerMsgWrapper {
        fn from(src: ManagerPong) -> Self {
            WorkerMsg::ManagerPong(src).into()
        }
    }

    impl From<TasksExecute> for WorkerMsgWrapper {
        fn from(src: TasksExecute) -> Self {
            WorkerMsg::TasksExecute(src).into()
        }
    }

    impl From<TasksPing> for WorkerMsgWrapper {
        fn from(src: TasksPing) -> Self {
            WorkerMsg::TasksPing(src).into()
        }
    }

    impl From<TasksPong> for WorkerMsgWrapper {
        fn from(src: TasksPong) -> Self {
            WorkerMsg::TasksPong(src).into()
        }
    }

    impl From<TasksAbord> for WorkerMsgWrapper {
        fn from(src: TasksAbord) -> Self {
            WorkerMsg::TasksAbord(src).into()
        }
    }

    impl From<TaskStatus> for WorkerMsgWrapper {
        fn from(src: TaskStatus) -> Self {
            WorkerMsg::TaskStatus(src).into()
        }
    }
}
